# Quiz Chapter 28

1. **When we fetch a Manager object from the `shelve` and print it, where does the display format logic come from?**
    In the final version of our class, `Manager` ultimately inherits its `__repr__` printing method from `AttrDisplay` in the separate `classtools` module and two levels up in the class tree. `Manager` doesn't have one itself, so the inheritance search climbs to its `Person` superclass; because there is no `__repr__` there either, the search climbs higher and finds it in `AttrDisplay`.

2. **When we fetch a `Person` object from a `shelve` without importing its module, how does the object know that it has a giveRaise method that we can call?**
    Shelves (really, the `pickle` module they use) automatically relink an instance to the class it was created from when that instance is later loaded back into memory. Python reimports the class from its module internally, creates an instance with its stored attributes, and sets the instance's `__class__` link to point to its original class. This way, loaded instances automatically obtain all their original methods, even if we have not imported the instance's class into our scope.

3. **Why is it so important to move processing into methods, instead of hardcoding it outside the class?**
    It's important to move processing into methods so that there is only one copy to change in the future, and so that methods can be run on any instance. This is Python's notion of `encapsulation`—wrapping up logic behind interfaces, to better support future code maintenance. If you don't do so, you create code redundancy that can multiply your work effort as the code evolves in the future.

4. **Why is it better to customize by subclassing rather than copying the original and modifying?**
    Customizing with subclasses reduces development effort. In OOP, we code by `customizing` what has already been done, rather than copying or changing existing code. This is the real "big idea" in OOP—because we can easily extend our prior work by coding new subclasses, we can leverage what we've already done. This is much better than either starting from scratch each time or introducing multiple redundant copies of code that may all have to be updated in the future.

5. **Why is it better to call back to a superclass method to run default actions, instead of copying and modifying its code in a subclass?**
    Copying and modifying code will double your potential work effort in the future, regardless of the context. If a subclass needs to perform default action coded in a superclass method, it's much better to call back to the original through the superclass's name thant copy its code. This also holds true for superclass constructors. Again, copying code creates redundancy, which is a major issue as code evolves.

6. **Why is it better to use tools like `__dict__` that allow objects to be processed generically than to write more custom code for each type of class?**
    Generic tools can avoid hardcoded solutions that must be kept in sync with the rest of the class as it evolves over time. A generic `__repr__` print method, for example, need not be updated each time a new attribute is added to instances in an `__init__` constructor. In addition, a generic print method inherited by all classes appears and need be modified in only one place—changes in the generic version are picked uop by all classes that inherit from the generic class. Again, eliminating code `redudancy` cuts future development effort; that's one of the primary assets classes bring to the table.

7. **In general terms, when might you choose to use object embedding and composition instead of inheritance?**
    Inheritance is best at coding extensions based on direct customization (like our `Manager` specialization of `Person`). Composition is well suited to scenarios where multiple objects are aggregated into a whole and directed by a controller layer class. Inheritance passes calls up to reuse, and composition passes down to delegate. Inheritance and composition are not mutually exclusive; often, the objects embedded in a controller are themselves customizations based upon inheritance. 

8. **What would you have to change if the objects coded in this chapter used a dictionary for names and a list for jobs, as in similar examples earlier in this book?**
    Not much since this was really a first-cut prototype, but the `lastName` method would need to be updated for the new name format; the `Person` constructor would have to change the job default to an empty list; and the `Manager` class would probably need to pass along a job list in its constructor instead of a single string (self-test  code would change as well of course). The good news is that these changes would need to be made in just one place—in our classes, where such details are encapsulated. The database scripts should work as is, as shelves support arbitrarily nested data. 

9. **How might you modify the classes in this chapter to implement a personal contacts database in Python?**
    The classes in this chapter could be used as boilerplate "template" code to implement a variety of types fo databases. Essentially, you can repurpose them by modifying the constructor to record different attributes and providing whatever methods are appropriate for the target application. For instance, you might use attributes such as `names, address, birthday, phone, email`, and so on for a contacts' database, and methods appropriate for this purpose. A method name `sendmail` for example, might use Python's standard library `smptlib` module to email one of the contacts automatically when called. The `AttrDisplay` tool we wrote here could be used verbatim to print your objects, because it is intentionally generic. Most of the `shelve` database code here can be used to store your objects too, with minor changes.
